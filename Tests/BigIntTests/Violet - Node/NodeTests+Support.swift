import XCTest
import BigInt

// Basically all of the code that does not need to be regenerated by Node.
extension NodeTests {

  // MARK: - Unary operations

  internal func plusTest(value: String,
                         expecting: String,
                         file: StaticString = #file,
                         line: UInt = #line) {
    self.unaryOp(value: value,
                 expecting: expecting,
                 op: { +$0 },
                 unsignedOp: { +$0 },
                 file: file,
                 line: line)
  }

  internal func minusTest(value: String,
                          expecting: String,
                          file: StaticString = #file,
                          line: UInt = #line) {
    self.unaryOp(value: value,
                 expecting: expecting,
                 op: { -$0 },
                 unsignedOp: nil, // no '-' for unsigned
                 file: file,
                 line: line)
  }

  internal func invertTest(value: String,
                           expecting: String,
                           file: StaticString = #file,
                           line: UInt = #line) {
    self.unaryOp(value: value,
                 expecting: expecting,
                 op: { ~$0 },
                 unsignedOp: { ~$0 },
                 file: file,
                 line: line)
  }

  internal typealias UnaryOperation = (BigInt) -> BigInt
  internal typealias UnsignedUnaryOperation = (BigUInt) -> BigUInt

  private func unaryOp(value _value: String,
                       expecting _expected: String,
                       op: UnaryOperation,
                       unsignedOp: UnsignedUnaryOperation?,
                       file: StaticString,
                       line: UInt) {
    // === Signed ===
    guard let value = self.parseInt(_value, file: file, line: line),
          let expected = self.parseInt(_expected, file: file, line: line) else {
      return
    }

    let result = op(value)
    XCTAssertEqual(result, expected, "Signed", file: file, line: line)

    // === Unsigned ===
    guard let uOp = unsignedOp,
          let uValue = self.parseUInt(_value, file: file, line: line),
          let uExpected = self.parseUInt(_expected, file: file, line: line) else {
      return
    }

    let uResult = uOp(uValue)
    XCTAssertEqual(uResult, uExpected, "Unsigned", file: file, line: line)
  }

  // MARK: - Binary operations

  internal func addTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 + $1 },
                  inoutOp: { $0 += $1 },
                  unsignedOp: { $0 + $1 },
                  unsignedInoutOp: { $0 += $1 },
                  file: file,
                  line: line)
  }

  internal func subTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 - $1 },
                  inoutOp: { $0 -= $1 },
                  unsignedOp: { $0 - $1 },
                  unsignedInoutOp: { $0 -= $1 },
                  file: file,
                  line: line)
  }

  internal func mulTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 * $1 },
                  inoutOp: { $0 *= $1 },
                  unsignedOp: { $0 * $1 },
                  unsignedInoutOp: { $0 *= $1 },
                  file: file,
                  line: line)
  }

  internal func divTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 / $1 },
                  inoutOp: { $0 /= $1 },
                  unsignedOp: { $0 / $1 },
                  unsignedInoutOp: { $0 /= $1 },
                  file: file,
                  line: line)
  }

  internal func modTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 % $1 },
                  inoutOp: { $0 %= $1 },
                  unsignedOp: { $0 % $1 },
                  unsignedInoutOp: { $0 %= $1 },
                  file: file,
                  line: line)
  }

  internal func andTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 & $1 },
                  inoutOp: { $0 &= $1 },
                  unsignedOp: { $0 & $1 },
                  unsignedInoutOp: { $0 &= $1 },
                  file: file,
                  line: line)
  }

  internal func orTest(lhs: String,
                       rhs: String,
                       expecting: String,
                       file: StaticString = #file,
                       line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 | $1 },
                  inoutOp: { $0 |= $1 },
                  unsignedOp: { $0 | $1 },
                  unsignedInoutOp: { $0 |= $1 },
                  file: file,
                  line: line)
  }

  internal func xorTest(lhs: String,
                        rhs: String,
                        expecting: String,
                        file: StaticString = #file,
                        line: UInt = #line) {
    self.binaryOp(lhs: lhs,
                  rhs: rhs,
                  expecting: expecting,
                  op: { $0 ^ $1 },
                  inoutOp: { $0 ^= $1 },
                  unsignedOp: { $0 ^ $1 },
                  unsignedInoutOp: { $0 ^= $1 },
                  file: file,
                  line: line)
  }

  internal typealias BinaryOperation = (BigInt, BigInt) -> BigInt
  internal typealias InoutBinaryOperation = (inout BigInt, BigInt) -> Void
  internal typealias UnsignedBinaryOperation = (BigUInt, BigUInt) -> BigUInt
  internal typealias UnsignedInoutBinaryOperation = (inout BigUInt, BigUInt) -> Void

  private func binaryOp(lhs _lhs: String,
                        rhs _rhs: String,
                        expecting _expected: String,
                        op: BinaryOperation,
                        inoutOp: InoutBinaryOperation,
                        unsignedOp: UnsignedBinaryOperation,
                        unsignedInoutOp: UnsignedInoutBinaryOperation,
                        file: StaticString,
                        line: UInt) {
    // === Signed ===
    guard let lhs = self.parseInt(_lhs, file: file, line: line),
          let lhsBeforeInout = self.parseInt(_lhs, file: file, line: line),
          let rhs = self.parseInt(_rhs, file: file, line: line),
          let expected = self.parseInt(_expected, file: file, line: line) else {
      return
    }

    let result = op(lhs, rhs)
    XCTAssertEqual(result, expected, "Signed", file: file, line: line)

    var inoutLhs = lhs
    inoutOp(&inoutLhs, rhs)
    XCTAssertEqual(inoutLhs, expected, "Signed inout", file: file, line: line)

    // Make sure that 'inout' operation did not modify 'lhs'.
    // (COW: they shared a single buffer -> inout should copy it before modification)
    let inoutMsg = "Signed inout did modify shared/original value"
    XCTAssertEqual(lhs, lhsBeforeInout, inoutMsg, file: file, line: line)

    // === Unsigned ===
    guard let uLhs = self.parseUInt(_lhs, file: file, line: line),
          let uLhsBeforeInout = self.parseUInt(_lhs, file: file, line: line),
          let uRhs = self.parseUInt(_rhs, file: file, line: line),
          let uExpected = self.parseUInt(_expected, file: file, line: line) else {
      return
    }

    let uResult = unsignedOp(uLhs, uRhs)
    XCTAssertEqual(uResult, uExpected, "Unsigned", file: file, line: line)

    var uInoutLhs = uLhs
    unsignedInoutOp(&uInoutLhs, uRhs)
    XCTAssertEqual(uInoutLhs, uExpected, "Unsigned inout", file: file, line: line)

    let uInoutMsg = "Unsigned inout did modify shared/original value"
    XCTAssertEqual(uLhs, uLhsBeforeInout, uInoutMsg, file: file, line: line)
  }

  // MARK: - Div mod

  internal func divModTest(lhs _lhs: String,
                           rhs _rhs: String,
                           div _div: String,
                           mod _mod: String,
                           file: StaticString = #file,
                           line: UInt = #line) {
    // === Signed ===
    guard let lhs = self.parseInt(_lhs, file: file, line: line),
          let rhs = self.parseInt(_rhs, file: file, line: line),
          let div = self.parseInt(_div, file: file, line: line),
          let mod = self.parseInt(_mod, file: file, line: line) else {
      return
    }

    let result = lhs.quotientAndRemainder(dividingBy: rhs)
    XCTAssertEqual(result.quotient, div, "Signed div", file: file, line: line)
    XCTAssertEqual(result.remainder, mod, "Signed mod", file: file, line: line)

    // === Unsigned ===
    guard let uLhs = self.parseUInt(_lhs, file: file, line: line),
          let uRhs = self.parseUInt(_rhs, file: file, line: line),
          let uDiv = self.parseUInt(_div, file: file, line: line),
          let uMod = self.parseUInt(_mod, file: file, line: line) else {
      return
    }

    let uResult = uLhs.quotientAndRemainder(dividingBy: uRhs)
    XCTAssertEqual(uResult.quotient, uDiv, "Unsigned div", file: file, line: line)
    XCTAssertEqual(uResult.remainder, uMod, "Unsigned mod", file: file, line: line)
  }

  // MARK: - Power

  internal func powerTest(base _base: String,
                          exponent: Int,
                          expecting _expected: String,
                          file: StaticString = #file,
                          line: UInt = #line) {
    // === Signed ===
    guard let base = self.parseInt(_base, file: file, line: line),
          let expected = self.parseInt(_expected, file: file, line: line) else {
      return
    }

    let result = base.power(exponent)
    XCTAssertEqual(result, expected, file: file, line: line)

    // === Unsigned ===
    guard let uBase = self.parseUInt(_base, file: file, line: line),
          let uExpected = self.parseUInt(_expected, file: file, line: line) else {
      return
    }

    let uResult = uBase.power(exponent)
    XCTAssertEqual(uResult, uExpected, file: file, line: line)
  }

  // MARK: - Shifts

  internal func shiftLeftTest(value: String,
                              count: Int,
                              expecting: String,
                              file: StaticString = #file,
                              line: UInt = #line) {
    self.shiftOp(value: value,
                 count: count,
                 expecting: expecting,
                 op: { $0 << $1 },
                 inoutOp: { $0 <<= $1 },
                 unsignedOp: { $0 << $1 },
                 unsignedInoutOp: { $0 <<= $1 },
                 file: file,
                 line: line)
  }

  internal func shiftRightTest(value: String,
                               count: Int,
                               expecting: String,
                               file: StaticString = #file,
                               line: UInt = #line) {
    self.shiftOp(value: value,
                 count: count,
                 expecting: expecting,
                 op: { $0 >> $1 },
                 inoutOp: { $0 >>= $1 },
                 unsignedOp: { $0 >> $1 },
                 unsignedInoutOp: { $0 >>= $1 },
                 file: file,
                 line: line)
  }

  internal typealias ShiftOperation = (BigInt, BigInt) -> BigInt
  internal typealias InoutShiftOperation = (inout BigInt, BigInt) -> Void
  internal typealias UnsignedShiftOperation = (BigUInt, BigUInt) -> BigUInt
  internal typealias UnsignedInoutShiftOperation = (inout BigUInt, BigUInt) -> Void

  private func shiftOp(value _value: String,
                       count _count: Int,
                       expecting _expected: String,
                       op: ShiftOperation,
                       inoutOp: InoutShiftOperation,
                       unsignedOp: UnsignedBinaryOperation,
                       unsignedInoutOp: UnsignedInoutBinaryOperation,
                       file: StaticString,
                       line: UInt) {

    // === Signed ===
    guard let value = self.parseInt(_value, file: file, line: line),
          let valueBeforeInout = self.parseInt(_value, file: file, line: line),
          let expected = self.parseInt(_expected, file: file, line: line) else {
      return
    }

    let count = BigInt(_count)

    let result = op(value, count)
    XCTAssertEqual(result, expected, "Signed", file: file, line: line)

    var inoutValue = value
    inoutOp(&inoutValue, count)
    XCTAssertEqual(inoutValue, expected, "Signed inout", file: file, line: line)

    // Make sure that 'inout' operation did not modify 'lhs'.
    // (COW: they shared a single buffer -> inout should copy it before modification)
    let inoutMsg = "Inout did modify shared/original value"
    XCTAssertEqual(value, valueBeforeInout, inoutMsg, file: file, line: line)

    // === Unsigned ===
    guard let uValue = self.parseUInt(_value, file: file, line: line),
          let uValueBeforeInout = self.parseUInt(_value, file: file, line: line),
          let uExpected = self.parseUInt(_expected, file: file, line: line) else {
      return
    }

    let uCount = BigUInt(_count)

    let uResult = unsignedOp(uValue, uCount)
    XCTAssertEqual(uResult, uExpected, "Unsigned", file: file, line: line)

    var uInoutLhs = uValue
    unsignedInoutOp(&uInoutLhs, uCount)
    XCTAssertEqual(uInoutLhs, uExpected, "Unsigned inout", file: file, line: line)

    let uInoutMsg = "Unsigned inout did modify shared/original value"
    XCTAssertEqual(uValue, uValueBeforeInout, uInoutMsg, file: file, line: line)
  }

  // MARK: - Helpers

  /// Abstraction over `BigInt(_:radix:)`.
  private func parseInt(_ string: String, file: StaticString, line: UInt) -> BigInt? {
    guard let result = BigInt(string) else {
      XCTFail("Unable to parse BigInt from: '\(string)'.", file: file, line: line)
      return nil
    }

    return result
  }

  /// Abstraction over `BigUInt(_:radix:)`.
  private func parseUInt(_ string: String, file: StaticString, line: UInt) -> BigUInt? {
    let isNegative = string.contains("-")
    if isNegative {
      return nil
    }

    // If we are positive then we should be able to parse it.
    guard let result = BigUInt(string) else {
      XCTFail("Unable to parse BigUInt from: '\(string)'.", file: file, line: line)
      return nil
    }

    return result
  }
}
